// Recipe 13.2 modified

// Add Rezende TPC equations
// function to calculate Tth (from a given Topt, which are our evolving phenotypes)
function (numeric)getTth(numeric Topt, numeric Q10, numeric d)
{
	Tth = Topt + 10.0/log(Q10) - sqrt( (1.0/d) + (10.0/log(Q10))^2.0);
	return Tth;
}

// get performance at given temperature (x) - note slim is particular about including decimal
function (numeric)tpc(numeric x, numeric Tth, numeric Q10, numeric d, numeric C)
{
	pf = rep(0.0, length(x));
	pf[x < Tth] = C*exp(x[x < Tth]*log(Q10)/10.0);
	// if only one Tth provided
	if (length(Tth) == 1){
		pf[x >= Tth] = C*exp(x[x >= Tth]*log(Q10)/10.0) * (1.0 - ( d*(x[x>=Tth]-Tth)^2.0) );
	}
	// if vector of Tth provided
	if (length(Tth) > 1){
		pf[x >= Tth] = C*exp(x[x >= Tth]*log(Q10)/10.0) * (1.0 - ( d*(x[x>=Tth]-Tth[x>=Tth])^2.0) );
	}
	pf[pf < 0.0] = 0.0;
	return pf;
}

// Rescale a performance curve by a Topt to a performance max=1.0
function (numeric)pfScaled(numeric pfs, numeric Topt, numeric Tth, numeric Q10, numeric d, numeric C)
{
	maxPf = tpc(Topt, Tth, Q10, d, C);
	scaledPfs = pfs / maxPf;
	return(scaledPfs);
}

// intialize
initialize() {
	// set working directory
	if (exists("slimgui"))
		setwd("C:\\Users\\brian\\Dropbox\\Projects\\017_SLiM_templeton\\analyses\\simulations\\Tb_emergent\\");
	else setwd("./");
	/// DEFINE CONSTANTS ///
	if (!exists("G")) defineConstant("G", 100000); // total generations
	// population features
	if (!exists("POP")) defineConstant("POP", 1);   // number of populations (VERIFY FUNCTIONALITY WITH >1)
	if (!exists("N")) defineConstant("N", 500);     // individuals per population	
	// locus features
	if (!exists("MU")) defineConstant("MU", 1e-7);  // mutation rate
	if (!exists("R")) defineConstant("R", 1e-8);   // recombination rate
	if (!exists("NPR")) defineConstant("NPR", 1);    // number of protein-coding loci (not counting the Tb locus)
	if (!exists("LEN")) defineConstant("LEN", 1000); // locus length
	//defineConstant("INT", 10000);  // interval between protein-coding loci (*replaced with free recombination between proteins)
	if (!exists("TBL")) defineConstant("TBL", 1000); // Body temperature (Tb) locus length
	// QTL-related constants 
	if (!exists("QTL_mu")) defineConstant("QTL_mu", 0);     // average mutation effect size
	if (!exists("QTL_sigma")) defineConstant("QTL_sigma", 0.1);	// SD of mutation effect sizes
	// Provide an start point and optimum for Tb 
	if (!exists("TBSTART")) defineConstant("TBSTART", 34.8);
	if (!exists("TBOPT")) defineConstant("TBOPT", 34.8);
	// Provide distribution of start points and optima for protein-coding loci
	if (!exists("PROTSTART")) defineConstant("PROTSTART", runif(NPR, 34.8, 34.8));
	//if (!exists("PROTOPT")) defineConstant("PROTOPT", runif(NPR, 37, 37));
	// Provide a starting environmental T, and an amount of change to a new temperature (delta Tenv)
	if (!exists("TENVMODEL")) defineConstant("TENVMODEL", F); // use model with Tenv: T/F
	if (!exists("TENV")) defineConstant("TENV", 34.8);
	if (!exists("DT")) defineConstant("DT", 1);
	// ID for logfile
	if (!exists("simID")) defineConstant("simID", "P"+NPR+"_M"+MU);
	//TPC
	//if (!exists("Tth")) defineConstant("TPC_Tth", 17.45);
	if (!exists("TPC_Q10")) defineConstant("TPC_Q10", 2.356); // 2.5
	if (!exists("TPC_d")) defineConstant("TPC_d", 0.0016);  // 0.0016
	if (!exists("TPC_C")) defineConstant("TPC_C", 0.129);  // 0.129
	// repeat for proteins 
	if (!exists("TPC_P_Q10")) defineConstant("TPC_P_Q10", 1.183);
	if (!exists("TPC_P_d")) defineConstant("TPC_P_d", 0.0013);
	if (!exists("TPC_P_C")) defineConstant("TPC_P_C", 5.77);
	
	
	/// INITIALIZE RUN ///
	initializeMutationRate(MU);
	
	// set recombination rates; proteins unlinked
	//	rates = c(rep(c(R, 0.5), NPR), R); // R within each protein, followed immediately by 0.5 for free recombination; final R for Tb
	rates = rep(c(R, 0.5), NPR); // R within each protein, followed immediately by 0.5 for free recombination; final R for Tb
	
	ends=NULL;
	for (index in 1:(NPR)) {
		ends = c(ends, asInteger(index*LEN - 1));
		ends = c(ends, asInteger(index*LEN));
	}
	//ends = c(ends, (NPR*LEN) + (TBL-1) ); // add one additional end for our Tb locus
	initializeRecombinationRate(rates = rates, ends = ends);
	
	
	// MUTATION TYPES
	// mutation type for body temperature
	//initializeMutationType("m0", 0.5, "n", QTL_mu, QTL_sigma);
	//m0.convertToSubstitution = F;
	// mutation type for each protein
	for (type_id in 1:NPR)
	{
		muttype = initializeMutationType(type_id, 0.5, "n", QTL_mu, QTL_sigma);
		muttype.convertToSubstitution = F;
	}
	
	// GENOMIC ELEMENT TYPES
	// g0 is the body temperature locus (Tb); all others are a QTL
	//initializeGenomicElementType("g0", c(m0), 1.0);
	// initialize GET
	for (index in 1:NPR) {
		initializeGenomicElementType(index, index, 1.0);
	}
	// add a neutral region type
	//	initializeGenomicElementType(NPR+1, NPR+1, 1.0);
	
	// GENOMIC ELEMENTS
	// protein-coding loci
	for (index in 0:(NPR-1)) {
		initializeGenomicElement(index+1, (index*LEN), ((index*LEN) + (LEN-1)) );
	
	}
	// Tb region
	//initializeGenomicElement(g0, (NPR*LEN), (NPR*LEN) + (TBL-1) );
	// Neutral locus at end
	//initializeGenomicElement(NPR+1, (NPR*LEN + NPR*INT) + (TBL-1) + 10000, (NPR*LEN + NPR*INT) + (TBL-1) + 16000);
}

/// Set up populations; remove fitness effects for m0 and m1..mn
//mutationEffect(m0) { return 1.0; }

1 early() {
	// set simulation to end in G generations
	community.rescheduleScriptBlock(s1, start=G, end=G);
	// add subpop(s)
	for (i in 1:POP)	{
		sim.addSubpop(i, N);
	}
	// loop through mutation types and give each fitness effect of 1.0
	for (type_id in 1:NPR)
	{
		sim.registerMutationEffectCallback(NULL, "{ return 1.0; }", type_id);
	}
}


// Sum up phenotypes; get fitness effects across quantitative traits
1: late() {
	
	inds = sim.subpopulations.individuals;
	
	// get mean protein phenotypes across individuals and emergent individual Tb
	meanProtein = NULL;
	tbIndSum = rep(0, N); // empty vector for sum of each individuals' protein phenoytpes
	for (type_id in 1:NPR)
	{
		phenotypes = PROTSTART[type_id-1] + inds.sumOfMutationsOfType(type_id);
		tbIndSum = tbIndSum + phenotypes;
		meanProtein = c(meanProtein, mean(phenotypes));
	}
	// calculate individuals' Tb as average of protein phenotypes (i.e. Tb an emergent trait)
	// NEW MEANING; tbInd is now the organismal Topt
	tbInd = tbIndSum / NPR;
	
	// get Tth
	Tth = getTth(Topt=tbInd, Q10=TPC_Q10, d=TPC_d);
	
	// get Tb from Tenv; midway through simulation, change Tenv
	if (sim.cycle < 10000)
		TBE = TENV;
	else
		TBE = TENV + DT;
	
	// get population mean of Tb
	tbPhenotype = mean(tbInd);
	
	// Print cycle number
	if (exists("slimgui") & sim.cycle % 1000 == 0){
		catn("CYCLE: " + sim.cycle);
	}
	
	// calculate fitness
	for (type_id in 1:NPR)
	{
		
		if (TENVMODEL == F) {
			// sum up QTL effects to get phenotype (i.e. locus' trait value)
			phenotypes = PROTSTART[type_id-1] + inds.sumOfMutationsOfType(type_id);
			//// difference between individual protein and mean (*WITH EMERGENT TB, tbIND MUST BE CALCULATED ABOVE)
			//effectsDif = 1 + dnorm(TB - phenotypes, 0, 5.0) * 10;
			
			// use phenotype (Topt,i) to get Tth for each TPC
			Tthi = getTth(Topt=phenotypes, Q10=TPC_P_Q10, d=TPC_P_d);
			
			// performance	
			pf = tpc(tbInd, Tth=Tthi, Q10=TPC_P_Q10, d=TPC_P_d, C=TPC_P_C);
			// The "1 +" allows control over strength of selection
			effectsDif = pfScaled(pf, Topt = phenotypes, Tth=Tthi, Q10=TPC_P_Q10, d=TPC_P_d, C=TPC_P_C); // deleted "*10"
			
			// scale inividual fitness 
			inds.fitnessScaling = inds.fitnessScaling * effectsDif; //* effectsLoc;
			
			// Every 1000 gen, print phenotypes and difference from starting value //optima
			if (exists("slimgui") & sim.cycle % 1000 == 0){
				catn("Mean protein " + type_id + ": " + mean(phenotypes) +
					"\t[DEV: " + (mean(phenotypes) - TBE) + "]");
			}
		}
		if (TENVMODEL == T) {
			// sum up QTL effects to get phenotype (i.e. locus' trait value)
			phenotypes = PROTSTART[type_id-1] + inds.sumOfMutationsOfType(type_id);
			//// difference between individual protein and mean (*WITH EMERGENT TB, tbIND MUST BE CALCULATED ABOVE)
			//effectsDif = 1 + dnorm(TB - phenotypes, 0, 5.0) * 10;
			
			// use phenotype (Topt,i) to get Tth for each TPC
			Tthi = getTth(Topt=phenotypes, Q10=TPC_P_Q10, d=TPC_P_d);
			
			// performance	
			pf = tpc(rep(TBE, N), Tth=Tthi, Q10=TPC_P_Q10, d=TPC_P_d, C=TPC_P_C);
			// The "1 +" allows control over strength of selection
			effectsDif = pfScaled(pf, Topt = phenotypes, Tth=Tthi, Q10=TPC_P_Q10, d=TPC_P_d, C=TPC_P_C); // deleted "*10"
			
			// scale inividual fitness 
			inds.fitnessScaling = inds.fitnessScaling * effectsDif; //* effectsLoc;
			
			// Every 1000 gen, print phenotypes and difference from starting value //optima
			if (exists("slimgui") & sim.cycle % 1000 == 0){
				catn("Mean protein " + type_id + ": " + mean(phenotypes) +
					"\t[DEV: " + (mean(phenotypes) - TBE) + "]");
			}
		}
	
	}
	
//	// now add in selection from Tb if using this model
//	if (TENVMODEL == T){
//		
//		// turn Tenv=Tb into a threshold temperature
//		Tth_Tb = getTth(Topt=tbInd, Q10=TPC_Q10, d=TPC_d);
//		// get performance curve
//		pf = tpc(rep(TBE, N), Tth=Tth_Tb, Q10=TPC_Q10, d=TPC_d, C=TPC_C);
//		// scale performance curve
//		effectsDif = pfScaled(pf, Topt = tbInd, Tth=Tth_Tb, Q10=TPC_Q10, d=TPC_d, C=TPC_C);
//		// scale inividual fitness (adjust by NPR)
//		//inds.fitnessScaling = inds.fitnessScaling * (effectsDif ^ NPR);
//		inds.fitnessScaling = inds.fitnessScaling * effectsDif;
//	}
	
	// Every 1000 gen, print Tb phenotypes and difference from starting value //optima
	if (exists("slimgui") & sim.cycle % 1000 == 0){
		catn("Mean phenotype Tb " + mean(tbPhenotype) +
			"\t[DEV: " + (mean(tbPhenotype) - TBE) + "]\n");
		//catn("Difference Tb " + (mean(tbPhenotype) - TBOPT) + "\n" );
	}
	
	
	// write a file logging cycle number, Tb phenotpye, and protein phenotypes
	if (sim.cycle == 1){
		// delete file if it exists
		if (fileExists("sim_log_"+simID+".txt"))
		{
			deleteFile("sim_log_"+simID+".txt");
		}
		// write column names
		writeFile("sim_log_"+simID+".txt", paste(c("cycle", "RF", "Tb", c( "Topt" + seq(1,NPR))), sep=","), append=T);
	}
	
	// log data to file every 1000 gens
	if (sim.cycle % 1000 == 0){
		writeFile("sim_log_"+simID+".txt", paste(c(sim.cycle, mean(inds.fitnessScaling), tbPhenotype, meanProtein), sep=","), append=T);
	}



}

/// END SIMULATION /// 
// THIS CALLBACK DOES NOTHING; ALLOWS 'G' TO SPECIFY NUMBER OF GENERATIONS
s1 1 late() {}


